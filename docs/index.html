<!doctype html>
<html lang="en">
<head>
    <link rel="manifest" href="manifest.json"/>
    <style>
        table {
            border-collapse: collapse;
        }

        table th {
            padding: 0.5rem;
            border-bottom: 5px solid black;
            border-left: 2px solid black;
        }

        th {
            position: sticky;
            top: 0;
            background-color: white;
            border-bottom: 5px solid black;
        }

        table td {
            padding: 0.5rem;
            border: 2px solid black;
        }

        table th:last-child {
            border-right: 2px solid black;
        }

        div.editable-table-cell {
            display: inline-block;
            outline: none;
        }

        td.results {
            text-align: end;
        }

        td.pass {
            background-color: green;
            color: white;
        }

        td.fail {
            background-color: darkred;
            color: white;
        }

        td.aborted {
            background-color: gray;
            text-align: center;
        }
    </style>
</head>
<body>
<section>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Baud Rate</legend>
        <select id="baud-rate-selector">
            <option value="300">300</option>
            <option value="600">300</option>
            <option value="1200" selected="selected">1200 (default)</option>
            <option value="2400">2400</option>
            <option value="9600">9600</option>
        </select>
    </fieldset>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Data Source</legend>
        <select id="data-source-selector">
            <option value="ftdi">FTDI</option>
            <option value="web-serial" selected="selected">WebSerial</option>
            <option value="simulator">Simulator</option>
            <option value="database">Database</option>
            <option value="results-db">Prev Results</option>
        </select>
        <input type="button" value="Connect" id="connect-button" style="font-size:2cqw; width:10vw; height:3vw">
    </fieldset>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Options</legend>
        <div style="display:inline-block">
            <input type="checkbox" id="enable-speech-checkbox">
            <label for="enable-speech-checkbox">Enable Speech</label>
        </div>
        <div style="display:inline-block">
            <input type="checkbox" id="enable-verbose-speech-checkbox">
            <label for="enable-verbose-speech-checkbox">Verbose</label>
        </div>
        <div style="display:inline-block">
            <input type="checkbox" id="speak-concentration-checkbox">
            <label for="speak-concentration-checkbox">Say particle count</label>
        </div>
    </fieldset>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Download Data</legend>
        <select id="download-file-format-selector">
            <option value="raw">Raw</option>
            <option value="csv" selected="selected">CSV</option>
            <option value="json">JSON</option>
        </select>
        <input type="button" value="Download!" id="download-button">
    </fieldset>
</section>
<br/>
<fieldset id="portacount-controls-fieldset" style="display:inline-block">
    <legend>PortaCount control</legend>
</fieldset>
<br/>
<section>
    <fieldset>
        <legend>Instructions</legend>
        <div id="instructions" style="width:fit-content;min-height:3rem; height:fit-content; font-size:xxx-large; overflow:auto; resize: both"></div>
    </fieldset>
</section>
<section id="collected-data">
    <fieldset>
        <legend>Test Info</legend>
        <div id="data-table-div" style="height: 10rem;min-height: 40vh; overflow: auto; resize: both">
            <table id="fit-test-data-table" style="font-size:2vw">
                <thead>
                <tr id="test-data-header-row">
                    <th>ID</th>
                    <th style="min-width:10vw">Time</th>
                    <th>Participant</th>
                    <th>Mask</th>
                    <th>Notes</th>
                </tr>
                </thead>
                <tbody id="test-data-body">

                </tbody>
            </table>
        </div>
    </fieldset>
</section>
<fieldset style="float:left">
    <legend>Raw Data</legend>
    <textarea id="raw-data" readonly style="width:40vw;height:200px" tabindex="1000"></textarea>
</fieldset>
<fieldset style="float:left">
    <legend>Processed Data</legend>
    <textarea id="interpreted-data" readonly style="width:300px;height:200px" tabindex="1001"></textarea>
</fieldset>
<fieldset style="float:left">
    <legend>Log</legend>
    <textarea id="log-text-area" readonly style="width:90vw;height:200px" tabindex="1002"></textarea>
</fieldset>

<script type="module" id="everything-in-one-module">
    /*
    Collect data from PortaCount 8020a
     */

    // data output patterns
    const PORTACOUNT_VERSION_PATTERN = /^PORTACOUNT\s+PLUS\S+PROM\S+(?<version>.+)/i; // PORTACOUNT PLUS PROM V1.7
    const COPYRIGHT_PATTERN = /^COPYRIGHT.+/i; // COPYRIGHT(c)1992 TSI INC
    const LICENSE_PATTERN = /^ALL\s+RIGHTS\s+RESERVED/i; // ALL RIGHTS RESERVED
    const SERIAL_NUMBER_PATTERN = /^Serial\s+Number\s+(?<serialNumber>\d+)/i; // Serial Number 17754
    const PASS_LEVEL_PATTERN = /^FF\s+pass\s+level\s+(?<passLevel>\d+)/i; // FF pass level = 100
    const NUM_EXERCISES_PATTERN = /^No\.\s+of\s+exers\s*=\s*(?<numExercises>\d+)/i; // No. of exers  = 4
    const AMBIENT_PURGE_PATTERN = /^Ambt\s+purge\s*=\s*(?<ambientPurgeTime>\d+)/i; // Ambt purge   = 4 sec.
    const AMBIENT_SAMPLE_PATTERN = /^Ambt\s+sample\s*=\s*(?<ambientSampleTime>\d+)/i; // Ambt sample  = 5 sec.
    const MASK_PURGE_PATTERN = /^Mask\s+purge\s*=\s*(?<maskPurgeTime>\d+)/i; // Mask purge  = 11 sec.
    const MASK_SAMPLE_PATTERN = /^Mask\s+sample\s+(?<exerciseNumber>\d+)\s*=\s*(?<maskSampleTime>\d+)/i; // Mask sample 1 = 40 sec.
    const DIP_SWITCH_PATTERN = /^DIP\s+switch\s+=\s+(?<dipSwitchBits>\d+)/i; // DIP switch  = 10111111
    const COUNT_READING_PATTERN = /^Conc\.\s+(?<concentration>[\d\.]+)/i; // Conc.      0.00 #/cc
    const NEW_TEST_PATTERN = /^NEW\s+TEST\s+PASS\s*=\s*(?<passLevel>\d+)/i; // NEW TEST PASS =  100
    const AMBIENT_READING_PATTERN = /^Ambient\s+(?<concentration>[\d\.]+)/i; // Ambient   2290 #/cc
    const MASK_READING_PATTERN = /^Mask\s+(?<concentration>[\d+\.]+)/i; // Mask    5.62 #/cc
    const FIT_FACTOR_PATTERN = /^FF\s+(?<exerciseNumber>\d+)\s+(?<fitFactor>[\d\.]+)\s+(?<result>.+)/; // FF  1    352 PASS
    const TEST_TERMINATED_PATTERN = /^Test\s+Terminated/i; // Test Terminated
    const OVERALL_FIT_FACTOR_PATTERN = /^Overall\s+FF\s+(?<fitFactor>[\d\.]+)\s+(?<result>.+)/i; // Overall FF    89 FAIL
    const LOW_PARTICLE_COUNT_PATTERN = /^(?<concentration>\d+)\/cc\s+Low\s+Particle\s+Count/i; // 970/cc Low Particle Count

    // external control patterns
    const PARTICLE_COUNT_PATTERN = /^\s*(?<concentration>\d+\.\d+)\s*/; // 006408.45


    export class DataCollector {
        static nextTabIndex = 100;
        resultsDatabase;
        beginExerciseTimoutId = null;
        logTextArea;
        dataTextArea;
        instructionsTextArea;
        currentTestData;
        testDataHeaderRow;
        testDataBody = null;
        testDataCurrentRow = null;
        tableElement;
        headerComplete = false;
        exerciseCount = 0; // we don't know up front how many exercises there are per test

        constructor(logTextArea, dataTextArea, instructionsTextArea, resultsDatabase) {
            this.logTextArea = logTextArea;
            this.dataTextArea = dataTextArea;
            this.instructionsTextArea = instructionsTextArea;
            this.testDataHeaderRow = document.getElementById("test-data-header-row");
            this.testDataBody = document.getElementById("test-data-body");
            this.tableDiv = document.getElementById("data-table-div");
            this.resultsDatabase = resultsDatabase;
            this.tableElement = document.getElementById("fit-test-data-table");
        }

        static getNextTabIndex() {
            const n = DataCollector.nextTabIndex;
            // advance by 2, so we can put the editor in the middle of adjacent cells and try to get shift-tab navigation to work properly
            // this doesn't seem to fix shift-tab tabindex traversal
            DataCollector.nextTabIndex += 2;
            return n;
        }

        appendToLog(message) {
            this.logTextArea.value += message;
            DataCollector.scrollToBottom(this.logTextArea);
        }

        appendToData(data) {
            this.dataTextArea.value += data;
            DataCollector.scrollToBottom(this.dataTextArea);
        }

        setInstructions(message) {
            this.instructionsTextArea.innerText = message;
            this.maybeSayItLater(message); // make sure instructions are queued.
        }

        setInstructionsForExercise(exerciseNum) {
            // TODO: don't hardcode this
            const exerciseInstructionsLookup = {
                1: "Normal breathing. Breathe normally.",
                2: "Heavy breathing. Take deep breaths.",
                3: "Jaw movement. Read a passage, sing a song, talk, or pretend to do so.",
                4: "Head movement. Look up, down, left, and right. Repeat."
            }
            this.setInstructions(`Perform exercise ${exerciseNum}: ${exerciseInstructionsLookup[exerciseNum]}`);
        }


        speechEnabled() {
            return document.getElementById("enable-speech-checkbox").checked;
        }

        speechVerbose() {
            return this.speechEnabled() && document.getElementById("enable-verbose-speech-checkbox").checked;
        }

        shouldSayParticleCount() {
            return this.speechEnabled() && document.getElementById("speak-concentration-checkbox").checked;
        }

        maybeSayIt(message) {
            if (this.speechEnabled()) {
                sayIt(message);
            }
        }

        maybeSayItLater(message) {
            if (this.speechEnabled()) {
                sayItLater(message);
            }
        }

        static scrollToBottom(theTextArea) {
            theTextArea.scrollTop = theTextArea.scrollHeight;
        }


        processLine(line) {
            // appendOutput(`processLine: ${line} (length: ${line.length})\n`);
            if (line.length === 0) {
                this.appendToLog("processLine() ignoring empty line\n");
                return;
            }
            // this.appendToLog(`${line}\n`);
            let match;

            match = line.match(NEW_TEST_PATTERN)
            if (match) {
                this.appendToData(`\nStarting a new test. ${new Date().toLocaleString()}\n`);
                this.setInstructionsForExercise(1);
                this.recordTestStart();
                return;
            }

            match = line.match(AMBIENT_READING_PATTERN);
            if (match) {
                let concentration = match.groups.concentration;
                this.appendToData(`ambient concentration: ${concentration}\n`);
                // this.currentTestData.samples.push({ambient: concentration});
                return;
            }

            match = line.match(MASK_READING_PATTERN);
            if (match) {
                let concentration = match.groups.concentration;
                this.appendToData(`mask concentration: ${concentration}\n`);
                this.setInstructions("Breathe normally");
                // this.currentTestData.samples.push({mask: concentration});
                return;
            }

            match = line.match(FIT_FACTOR_PATTERN);
            if (match) {
                const ff = match.groups.fitFactor;
                const exerciseNum = Number(match.groups.exerciseNumber);
                const result = match.groups.result;
                this.appendToData(`Exercise ${exerciseNum}: Fit factor is ${ff}. Result: ${result}\n`)
                this.setInstructionsForExercise(exerciseNum + 1);
                this.maybeSayItLater(`Score was ${ff}`)
                // this.beginExerciseTimoutId = this.scheduleBeginExercisePrompt(exerciseNum+1);
                // this.currentTestData.results.push({exercise_num: exerciseNum, fit_factor: ff, result: result});
                this.recordExerciseResult(exerciseNum, ff, result);
                return;
            }

            match = line.match(OVERALL_FIT_FACTOR_PATTERN);
            if (match) {
                const ff = match.groups["fitFactor"];
                const result = match.groups["result"];
                this.appendToData(`\nTest complete. ${result} with FF of ${ff}\n`);
                this.setInstructions(`Test complete. Score: ${ff}`);
                // this.currentTestData.results.push({exercise_num: "overall", fit_factor: ff, result: result});
                this.appendToLog(JSON.stringify(this.currentTestData) + "\n");
                this.recordTestComplete(ff, result);
                return;
            }

            if (line.match(TEST_TERMINATED_PATTERN)) {
                this.appendToData(`\nTest aborted\n`);
                this.setInstructions("Breathe normally");
                this.recordTestAborted();
                return;
            }

            match = line.match(COUNT_READING_PATTERN) || line.match(PARTICLE_COUNT_PATTERN);
            if (match) {
                if (!isSayingSomething()) {
                    const concentration = Number(match.groups.concentration);
                    if (this.shouldSayParticleCount()) {
                        const intConcentration = Math.ceil(concentration);
                        const conc = intConcentration < 20 ? (Math.ceil(concentration * 10) / 10).toFixed(1) : intConcentration;
                        const message = this.speechVerbose() ? `Particle count is ${conc}` : conc;
                        this.maybeSayIt(message);
                    }
                }
            }

        }

        recordTestComplete(ff, result) {
            if (!this.headerComplete) {
                this.addColumnToHeader("Final"); // alts: Overall, Net, Avg/Average, H-Mean / Mean
                this.headerComplete = true;
            }
            this.appendExerciseResult(ff, result);
        }

        recordTestAborted() {
            if (!this.testDataCurrentRow) {
                console.log("no current row, ignoring");
                return;
            }
            const cell = document.createElement("td");
            cell.setAttribute("colspan", "100%");
            cell.innerText = `aborted`;
            cell.classList.add("aborted");
            this.testDataCurrentRow.appendChild(cell);
            this.setInstructions("Test cancelled.");
            this.updateCurrentRowInDatabase();
        }

        /**
         * target must be a table cell (td)
         * Use a contentEditable DIV for auto-resizing editing box: https://stackoverflow.com/a/15866077
         * @param target
         * @return a Promise that completes when focus is lost
         */
        static beginEditing(target) {
            const input = document.createElement("div");
            input.setAttribute("contentEditable", "true");

            /** Swap out the tabindex with the input element so shift-tab works properly.
             * Otherwise, shift-tabbing will focus on the target (the td, which will re-enable editing mode).
             * Removing the tabindex on the td means shift-tab will focus on the cell to its left as intended.
             */
            input.setAttribute("tabindex", target.getAttribute("tabindex"));
            target.removeAttribute("tabindex");

            input.classList.add("editable-table-cell")
            input.innerHTML = target.innerHTML;
            target.replaceChildren(input);
            input.focus();

            return new Promise((resolve) => {
                input.onblur = (event) => {
                    target.setAttribute("tabindex", input.getAttribute("tabindex"));
                    // target.replaceChildren();
                    target.innerHTML = input.innerHTML;
                    resolve();
                }
            });
        }


        async recordTestStart(timestamp = new Date().toLocaleString()) {
            const table = this.tableElement;

            // TODO: use databinding
            function createTimestampCell() {
                const cell = document.createElement("td");
                cell.innerText = timestamp;
                return cell;
            }

            const resultsDb = this.resultsDatabase;
            function createEditableTableCell(parentRow) {
                const cell = document.createElement("td");
                cell.classList.add("editable");
                cell.setAttribute("tabindex", "" + DataCollector.getNextTabIndex());
                cell.onfocus = () => {
                    DataCollector.beginEditing(cell).then(() => {
                        const columns = getTableColumnNames(table);
                        const record = jsonifyTableRow(columns,parentRow);
                        resultsDb.updateTest(record);
                    });
                };
                return cell;
            }

            this.currentTestData = await this.resultsDatabase.createNewTest(); // primary key is the "ID" field
            this.currentTestData["Time"] = timestamp;
            // jsonifyTableRow(this.currentTestData);
            // updateTest()

            const row = this.testDataBody.insertRow(0);
            this.testDataCurrentRow = row;

            let testNumCell = document.createElement("td");
            testNumCell.innerText = this.currentTestData.ID;

            row.appendChild(testNumCell);
            row.appendChild(createTimestampCell(timestamp));

            row.appendChild(createEditableTableCell(row)); // participant
            row.appendChild(createEditableTableCell(row)); // mask
            row.appendChild(createEditableTableCell(row)); // notes

            // scroll to top (since we're inserting at the top
            this.tableDiv.scrollTop = 0;
        }

        recordExerciseResult(exerciseNum, ff, result) {
            if (this.exerciseCount < exerciseNum) {
                this.addColumnToHeader(`Ex ${exerciseNum}`);
                this.exerciseCount++;
            }
            this.appendExerciseResult(ff, result);
        }

        appendExerciseResult(ff, result) {
            if (!this.testDataCurrentRow) {
                console.log("no current row, ignoring");
                return;
            }
            const exerciseResultCell = document.createElement("td");
            exerciseResultCell.innerText = `${Math.floor(ff)}`;
            exerciseResultCell.classList.add(result.toLowerCase(), "results");  // todo: parse this out explicitly to pass/fail
            this.testDataCurrentRow.appendChild(exerciseResultCell);
            this.updateCurrentRowInDatabase();
        }

        updateCurrentRowInDatabase() {
            const columns = getTableColumnNames(this.tableElement);
            const record = jsonifyTableRow(columns, this.testDataCurrentRow);
            this.resultsDatabase.updateTest(record);
        }

        addColumnToHeader(heading) {
            const columnHeading = document.createElement("th");
            columnHeading.style.minWidth = "5vw";
            columnHeading.innerText = heading;
            this.testDataHeaderRow.appendChild(columnHeading);
        }

        /**
         * When we get results from the previous exercise, we can prompt the participant to start the next exercise.
         * If we've finished the last exercise of the test, we'll get the overall fit factor result soon. So we should
         * delay prompting for the next exercise in this case.
         * @param nextExerciseNum
         * @returns {number}
         */
        scheduleBeginExercisePrompt(nextExerciseNum) {
            const timeoutMs = 3200;
            const timeoutId = setTimeout(() => {
                this.beginExerciseTimoutId = null;
                this.setInstructionsForExercise(nextExerciseNum);
            }, timeoutMs);
            return timeoutId;
        }

        cancelBeginExercisePrompt() {
            if (this.beginExerciseTimoutId !== null) {
                this.appendToLog("cancelling begin exercise prompt\n");
                clearTimeout(this.beginExerciseTimoutId);
                this.beginExerciseTimoutId = null;
            }
        }
    }


    /*
     Text-to-speech functions
     */
    let selectedVoice;
    let speechRate = 1;
    let speechSynthesis;

    export function setupSpeechSynthesis() {
        const synth = window.speechSynthesis;
        const inputForm = document.querySelector("form");
        const inputTxt = document.getElementById("say-this");
        const voiceSelect = document.getElementById("voice-select");
        const speechSpeedElement = document.getElementById("speech-speed");
        const speechRateLabel = document.getElementById("speech-rate-label");
        let voices;

        function populateVoiceList() {
            voices = synth.getVoices();

            for (const voice of voices) {
                const option = document.createElement("option");
                option.textContent = `${voice.name} (${voice.lang})`;

                if (voice.default) {
                    option.textContent += " — DEFAULT";
                    option.selected = true;
                }

                option.setAttribute("data-lang", voice.lang);
                option.setAttribute("data-name", voice.name);
                voiceSelect.appendChild(option);
            }
            voiceSelect.onchange = event => selectedVoice = voices.find((voice) => voice.name === event.target.getAttribute("data-name"));

            speechSpeedElement.onchange = event => {
                speechRate = event.target.value;
                speechRateLabel.innerText = speechRate;
            }
            speechSpeedElement.value = speechRate; // init
            speechRateLabel.innerText = speechRate; // init
        }

        populateVoiceList();
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = populateVoiceList;
        }


        inputForm.onsubmit = (event) => {
            event.preventDefault();

            sayIt(inputTxt.value);
            inputTxt.blur();
        };

        speechSynthesis = synth;
    }

    export function quickSetupSpeechSynthesis() {
        const synth = window.speechSynthesis;
        const defaultVoice = synth.getVoices().find((voice) => voice.default);

        if (synth.onvoiceschanged !== undefined) {
            // synth.onvoiceschanged = populateVoiceList;
        }

        speechSynthesis = synth;
        selectedVoice = defaultVoice;
        speechRate = 1;
    }

    export function isSayingSomething() {
        return speechSynthesis.speaking;
    }

    /**
     * enqueue
     * @param message
     */
    export function sayItLater(message) {
        console.log(`say it later: ${message}`)
        const utterThis = new SpeechSynthesisUtterance(message);
        utterThis.voice = selectedVoice;
        utterThis.rate = speechRate;

        speechSynthesis.speak(utterThis); // this enqueues
    }

    export function sayIt(message) {
        console.log(`say it ${message}`)
        const utterThis = new SpeechSynthesisUtterance(message);
        utterThis.voice = selectedVoice;
        utterThis.rate = speechRate;

        if(speechSynthesis.speaking) {
            speechSynthesis.cancel(); // stop current utterance
            // chrome needs a delay here for some reason, otherwise speak doesn't do anything.
            // 60 ms seems to be around the minimum delay
            setTimeout(() => speechSynthesis.speak(utterThis), 60)
        } else {
            speechSynthesis.speak(utterThis);
        }
    }

    /*
    Download data from an HTML elements in various formats.
    Not all combination of elements and formats are supported.
    */


    function getFilenamePrefix(htmlElement, filenamePrefixHint = "data") {
        return (htmlElement.id || htmlElement.nodeName || filenamePrefixHint) + "_";
    }

    /**
     * Download the terminal's contents to a file. from https://github.com/GoogleChromeLabs/serial-terminal/blob/main/src/index.ts
     */
    function createFauxLink(fileName, contents) {
        const linkContent = URL.createObjectURL(
            new Blob([new TextEncoder().encode(contents).buffer],
                {type: 'text/plain'}));
        const fauxLink = document.createElement('a');
        fauxLink.download = fileName;
        fauxLink.href = linkContent;
        return fauxLink;
    }

    /**
     * @param htmlElement must have a value property (for now)
     * @param filenameHint
     */
    export function downloadRawData(htmlElement, filenameHint = "data") {
        const fauxLink = createFauxLink(`${getFilenamePrefix(htmlElement, filenameHint)}${new Date().getTime()}.txt`, htmlElement.value);
        fauxLink.click();
    }

    export function downloadTableAsCSV(tableElement, filenameHint = "table") {
        const tableData = [];
        const rowElements = tableElement.getElementsByTagName("tr");
        for (let row = 0; row < rowElements.length; row++) {
            const rowData = [];
            let cells = rowElements[row].getElementsByTagName("td");
            if (cells.length === 0) {
                cells = rowElements[row].getElementsByTagName("th");
            }
            for (let i = 0; i < cells.length; i++) {
                rowData.push(cells[i].innerText);
            }
            tableData.push(rowData.map((value) => `"${value.replaceAll("\"", "\"\"")}"`).join(","));
        }

        const fauxLink = createFauxLink(`${getFilenamePrefix(tableElement, filenameHint)}${new Date().getTime()}.csv`, tableData.join("\n"));
        fauxLink.click();
    }

    export function jsonifyTableRow(orderedColumnNames, tableRowElement) {
        const orderedColumnCells = tableRowElement.getElementsByTagName("td");
        const rowData = {};
        for (let i = 0; i < orderedColumnNames.length; i++) {
            if (orderedColumnCells.length <= i) {
                break; // no more cells (aborted)
            }
            rowData[orderedColumnNames[i]] = orderedColumnCells[i].innerText; // todo: convert line breaks
        }
        return rowData;
    }

    export function getTableColumnNames(tableElement) {
        const columnHeadingElements = tableElement.getElementsByTagName("th");
        const columnNames = [];
        for (let i = 0; i < columnHeadingElements.length; i++) {
            columnNames.push(columnHeadingElements[i].innerText);
        }
        return columnNames;
    }

    export function downloadTableAsJSON(tableElement, filenameHint = "table") {
        const columnNames = getTableColumnNames(tableElement);

        const tableData = [];
        const rowElements = tableElement.getElementsByTagName("tr");
        for (let rowIndex = 0; rowIndex < rowElements.length; rowIndex++) {
            let tableRowElement = rowElements[rowIndex];
            const rowData = jsonifyTableRow(columnNames, tableRowElement);
            tableData.push(rowData);
        }

        const fauxLink = createFauxLink(`${getFilenamePrefix(tableElement, filenameHint)}${new Date().getTime()}.json`, JSON.stringify(tableData));
        fauxLink.click();
    }


    /*
    manually inline the ftdi driver
     */
    /*
        WebUSB FTDI Driver v0.01a
        (C) 2020 Shaped Technologies (Jai B.)

        GPL v2 free for personal use / commercial or closed source use requires commercial license - contact us.

        This wouldn't have been possible without the Linux driver, so shoutout to the developers of that!

        Data Transfer Efficiency / Bulk Transfers Technical Note
        https://www.ftdichip.com/Support/Documents/TechnicalNotes/TN_103_FTDI_USB_Data_Transfer_Efficiency(FT_000097).pdf

        Chipset feature comparison:
        https://www.ftdichip.com/Support/Documents/TechnicalNotes/TN_107%20FTDI_Chipset_Feature_Comparison.pdf

        https://www.ftdichip.com/Support/Documents/AppNotes/AN232B-04_DataLatencyFlow.pdf

    */

    /*

    USB_SETUP_HOST_TO_DEVICE	0x00	Transfer direction: host to device
    USB_SETUP_DEVICE_TO_HOST	0x80	Transfer direction: device to host
    USB_SETUP_TYPE_STANDARD		0x00	Type: standard
    USB_SETUP_TYPE_CLASS		0x20	Type: class
    USB_SETUP_TYPE_VENDOR		0x40	Type: vendor
    USB_SETUP_RECIPIENT_DEVICE	0x00	Recipient: device
    USB_SETUP_RECIPIENT_INTERFACE	0x01	Recipient: interface
    USB_SETUP_RECIPIENT_ENDPOINT	0x02	Recipient: endpoint
    USB_SETUP_RECIPIENT_OTHER	0x03	Recipient: other

    */

    class WebUSBSerialPort {
        /* Commands */
        #FTDI_SIO_RESET 				= 0x00; /* Reset the port */
        #FTDI_SIO_MODEM_CTRL			= 0x01; /* Set the modem control register */
        #FTDI_SIO_SET_FLOW_CTRL 		= 0x02; /* Set flow control register */
        #FTDI_SIO_SET_BAUD_RATE 		= 0x03; /* Set baud rate */
        #FTDI_SIO_SET_DATA				= 0x04; /* Set the data characteristics of the port */
        #FTDI_SIO_GET_MODEM_STATUS		= 0x05; /* Retrieve current value of modem status register */
        #FTDI_SIO_SET_EVENT_CHAR		= 0x06; /* Set the event character */
        #FTDI_SIO_SET_ERROR_CHAR		= 0x07; /* Set the error character */
        #FTDI_SIO_SET_LATENCY_TIMER		= 0x09; /* Set the latency timer */
        #FTDI_SIO_GET_LATENCY_TIMER 	= 0x0a; /* Get the latency timer */
        #FTDI_SIO_SET_BITMODE			= 0x0b; /* Set bitbang mode */
        #FTDI_SIO_READ_PINS				= 0x0c; /* Read immediate value of pins */
        #FTDI_SIO_READ_EEPROM			= 0x90; /* Read EEPROM */

        /* not in linux driver? */
        #FTDI_BitMode_Reset       = 0x00;
        #FTDI_BitMode_BitBang     = 0x01;
        #FTDI_BitMode_MPSSE       = 0x02;
        #FTDI_BitMode_SyncBitBang = 0x04;
        #FTDI_BitMode_MCU         = 0x08;
        #FTDI_BitMode_Opto        = 0x10;
        #FTDI_BitMode_CBus        = 0x20;
        #FTDI_BitMode_SyncFIFO    = 0x40;

        /* Interface indices for FT2232, FT2232H and FT4232H devices */
        #INTERFACE_A		= 1;
        #INTERFACE_B		= 2;
        #INTERFACE_C		= 3;
        #INTERFACE_D		= 4;

        /* Port Identifier Table */
        #PIT_DEFAULT		= 0; /* SIOA */
        #PIT_SIOA			= 1; /* SIOA */

        /* The device this driver is tested with one has only one port */
        #PIT_SIOB			= 2; /* SIOB */
        #PIT_PARALLEL		= 3; /* Parallel */

        /* FTDI_SIO_RESET
         BmRequestType:  0100 0000B
         bRequest:       FTDI_SIO_RESET
         wValue:         Control Value
                           0 = Reset SIO
                           1 = Purge RX buffer
                           2 = Purge TX buffer
         wIndex:         Port
         wLength:        0
         Data:           None

         The Reset SIO command has this effect:

            Sets flow control set to 'none'
            Event char = $0D
            Event trigger = disabled
            Purge RX buffer
            Purge TX buffer
            Clear DTR
            Clear RTS
            baud and data format not reset

         The Purge RX and TX buffer commands affect nothing except the buffers

        */
        #FTDI_SIO_RESET_REQUEST 	= this.#FTDI_SIO_RESET;
        #FTDI_SIO_RESET_REQUEST_TYPE = 'vendor';
        #FTDI_SIO_RESET_SIO 		= 0;
        #FTDI_SIO_RESET_PURGE_RX 	= 1;
        #FTDI_SIO_RESET_PURGE_TX 	= 2;

        /* FTDI_SIO_SET_BAUDRATE */
        #FTDI_SIO_SET_BAUDRATE_REQUEST 		= 0x03;


        #ftdi_chip_type = {
            SIO : 1,
            FT8U232AM : 2,
            FT232BM : 3,
            FT2232C : 4,
            FT232RL : 5,
            FT2232H : 6,
            FT4232H : 7,
            FT232H  : 8,
            FTX     : 9
        };

        /*
          BmRequestType:  0100 0000B
          bRequest:       FTDI_SIO_SET_BAUDRATE
          wValue:         BaudDivisor value - see below
          wIndex:         Port
          wLength:        0
          Data:           None
          The BaudDivisor values are calculated as follows:
          - BaseClock is either 12000000 or 48000000 depending on the device.
            FIXME: I wish I knew how to detect old chips to select proper base clock!
          - BaudDivisor is a fixed point number encoded in a funny way.
            (--WRONG WAY OF THINKING--)
            BaudDivisor is a fixed point number encoded with following bit weighs:
            (-2)(-1)(13..0). It is a radical with a denominator of 4, so values
            end with 0.0 (00...), 0.25 (10...), 0.5 (01...), and 0.75 (11...).
            (--THE REALITY--)
            The both-bits-set has quite different meaning from 0.75 - the chip
            designers have decided it to mean 0.125 instead of 0.75.
            This info looked up in FTDI application note "FT8U232 DEVICES \ Data Rates
            and Flow Control Consideration for USB to RS232".
          - BaudDivisor = (BaseClock / 16) / BaudRate, where the (=) operation should
            automagically re-encode the resulting value to take fractions into
            consideration.
          As all values are integers, some bit twiddling is in order:
            BaudDivisor = (BaseClock / 16 / BaudRate) |
            (((BaseClock / 2 / BaudRate) & 4) ? 0x4000    // 0.5
             : ((BaseClock / 2 / BaudRate) & 2) ? 0x8000  // 0.25
             : ((BaseClock / 2 / BaudRate) & 1) ? 0xc000  // 0.125
             : 0)

          For the FT232BM, a 17th divisor bit was introduced to encode the multiples
          of 0.125 missing from the FT8U232AM.  Bits 16 to 14 are coded as follows
          (the first four codes are the same as for the FT8U232AM, where bit 16 is
          always 0):
            000 - add .000 to divisor
            001 - add .500 to divisor
            010 - add .250 to divisor
            011 - add .125 to divisor
            100 - add .375 to divisor
            101 - add .625 to divisor
            110 - add .750 to divisor
            111 - add .875 to divisor
          Bits 15 to 0 of the 17-bit divisor are placed in the urb value.  Bit 16 is
          placed in bit 0 of the urb index.

          Note that there are a couple of special cases to support the highest baud
          rates.  If the calculated divisor value is 1, this needs to be replaced with
          0.  Additionally for the FT232BM, if the calculated divisor value is 0x4001
          (1.5), this needs to be replaced with 0x0001 (1) (but this divisor value is
          not supported by the FT8U232AM).
         */
        #ftdi_sio_baudrate = {
            ftdi_sio_b300 : 0,
            ftdi_sio_b600 : 1,
            ftdi_sio_b1200 : 2,
            ftdi_sio_b2400 : 3,
            ftdi_sio_b4800 : 4,
            ftdi_sio_b9600 : 5,
            ftdi_sio_b19200 : 6,
            ftdi_sio_b38400 : 7,
            ftdi_sio_b57600 : 8,
            ftdi_sio_b115200 : 9
        };

        /* FTDI_SIO_SET_DATA
          BmRequestType:  0100 0000B
          bRequest:       FTDI_SIO_SET_DATA
          wValue:         Data characteristics (see below)
          wIndex:         Port
          wLength:        0
          Data:           No

          Data characteristics

            B0..7   Number of data bits
            B8..10  Parity
                    0 = None
                    1 = Odd
                    2 = Even
                    3 = Mark
                    4 = Space
            B11..13 Stop Bits
                    0 = 1
                    1 = 1.5
                    2 = 2
            B14
                    1 = TX ON (break)
                    0 = TX OFF (normal state)
            B15 Reserved

         */
        #FTDI_SIO_SET_DATA_REQUEST	= this.#FTDI_SIO_SET_DATA;
        #FTDI_SIO_SET_DATA_PARITY_NONE	= (0x0 << 8);
        #FTDI_SIO_SET_DATA_PARITY_ODD	= (0x1 << 8);
        #FTDI_SIO_SET_DATA_PARITY_EVEN	= (0x2 << 8);
        #FTDI_SIO_SET_DATA_PARITY_MARK	= (0x3 << 8);
        #FTDI_SIO_SET_DATA_PARITY_SPACE	= (0x4 << 8);
        #FTDI_SIO_SET_DATA_STOP_BITS_1	= (0x0 << 11);
        #FTDI_SIO_SET_DATA_STOP_BITS_15	= (0x1 << 11);
        #FTDI_SIO_SET_DATA_STOP_BITS_2	= (0x2 << 11);
        #FTDI_SIO_SET_BREAK				= (0x1 << 14);

        /* FTDI_SIO_MODEM_CTRL

          BmRequestType:   0100 0000B
          bRequest:        FTDI_SIO_MODEM_CTRL
          wValue:          ControlValue (see below)
          wIndex:          Port
          wLength:         0
          Data:            None

          NOTE: If the device is in RTS/CTS flow control, the RTS set by this
          command will be IGNORED without an error being returned
          Also - you can not set DTR and RTS with one control message
         */
        #FTDI_SIO_SET_MODEM_CTRL_REQUEST 		= this.#FTDI_SIO_MODEM_CTRL;

        /*
         ControlValue
         B0    DTR state
                  0 = reset
                  1 = set
         B1    RTS state
                  0 = reset
                  1 = set
         B2..7 Reserved
         B8    DTR state enable
                  0 = ignore
                  1 = use DTR state
         B9    RTS state enable
                  0 = ignore
                  1 = use RTS state
         B10..15 Reserved
        */

        #FTDI_SIO_SET_DTR_MASK = 0x1;
        #FTDI_SIO_SET_DTR_HIGH = ((this.#FTDI_SIO_SET_DTR_MASK  << 8) | 1);
        #FTDI_SIO_SET_DTR_LOW  = ((this.#FTDI_SIO_SET_DTR_MASK  << 8) | 0);
        #FTDI_SIO_SET_RTS_MASK = 0x2;
        #FTDI_SIO_SET_RTS_HIGH = ((this.#FTDI_SIO_SET_RTS_MASK << 8) | 2);
        #FTDI_SIO_SET_RTS_LOW  = ((this.#FTDI_SIO_SET_RTS_MASK << 8) | 0);

        /* FTDI_SIO_SET_FLOW_CTRL
           BmRequestType:  0100 0000b
           bRequest:       FTDI_SIO_SET_FLOW_CTRL
           wValue:         Xoff/Xon
           wIndex:         Protocol/Port - hIndex is protocol / lIndex is port
           wLength:        0
           Data:           None

         hIndex protocol is:
           B0 Output handshaking using RTS/CTS
               0 = disabled
               1 = enabled
           B1 Output handshaking using DTR/DSR
               0 = disabled
               1 = enabled
           B2 Xon/Xoff handshaking
               0 = disabled
               1 = enabled

         A value of zero in the hIndex field disables handshaking

         If Xon/Xoff handshaking is specified, the hValue field should contain the
         XOFF character and the lValue field contains the XON character.
         */
        #FTDI_SIO_SET_FLOW_CTRL_REQUEST = this.#FTDI_SIO_SET_FLOW_CTRL;
        #FTDI_SIO_DISABLE_FLOW_CTRL = 0x0;
        #FTDI_SIO_RTS_CTS_HS = (0x1 << 8);
        #FTDI_SIO_DTR_DSR_HS = (0x2 << 8);
        #FTDI_SIO_XON_XOFF_HS = (0x4 << 8);

        /*
         FTDI_SIO_GET_LATENCY_TIMER

         Set the timeout interval. The FTDI collects data from the
         device, transmitting it to the host when either A) 62 bytes are
         received, or B) the timeout interval has elapsed and the buffer
         contains at least 1 byte.  Setting this value to a small number
         can dramatically improve performance for applications which send
         small packets, since the default value is 16ms.

          BmRequestType:   1100 0000b
          bRequest:        FTDI_SIO_GET_LATENCY_TIMER
          wValue:          0
          wIndex:          Port
          wLength:         0
          Data:            latency (on return)
         */
        #FTDI_SIO_GET_LATENCY_TIMER_REQUEST = this.#FTDI_SIO_GET_LATENCY_TIMER;

        /*
         FTDI_SIO_SET_LATENCY_TIMER

         Set the timeout interval. The FTDI collects data from the
         device, transmitting it to the host when either A) 62 bytes are
         received, or B) the timeout interval has elapsed and the buffer
         contains at least 1 byte.  Setting this value to a small number
         can dramatically improve performance for applications which send
         small packets, since the default value is 16ms.

          BmRequestType:   0100 0000b
          bRequest:        FTDI_SIO_SET_LATENCY_TIMER
          wValue:          Latency (milliseconds)
          wIndex:          Port
          wLength:         0
          Data:            None

         wValue:
           B0..7   Latency timer
           B8..15  0

        */
        #FTDI_SIO_SET_LATENCY_TIMER_REQUEST = this.#FTDI_SIO_SET_LATENCY_TIMER;


        /*
         FTDI_SIO_SET_EVENT_CHAR

         Set the special event character for the specified communications port.
         If the device sees this character it will immediately return the
         data read so far - rather than wait 40ms or until 62 bytes are read
         which is what normally happens.

          BmRequestType:   0100 0000b
          bRequest:        FTDI_SIO_SET_EVENT_CHAR
          wValue:          EventChar
          wIndex:          Port
          wLength:         0
          Data:            None

         wValue:
           B0..7   Event Character
           B8      Event Character Processing
                     0 = disabled
                     1 = enabled
           B9..15  Reserved

         FTDI_SIO_SET_ERROR_CHAR
         Set the parity error replacement character for the specified communications
         port
          BmRequestType:  0100 0000b
          bRequest:       FTDI_SIO_SET_EVENT_CHAR
          wValue:         Error Char
          wIndex:         Port
          wLength:        0
          Data:           None

        Error Char
          B0..7  Error Character
          B8     Error Character Processing
                   0 = disabled
                   1 = enabled
          B9..15 Reserved

         */

        #FTDI_SIO_SET_EVENT_CHAR_REQUEST = this.#FTDI_SIO_SET_EVENT_CHAR;


        /* FTDI_SIO_GET_MODEM_STATUS
         Retrieve the current value of the modem status register
           BmRequestType:   1100 0000b
           bRequest:        FTDI_SIO_GET_MODEM_STATUS
           wValue:          zero
           wIndex:          Port
           wLength:         1
           Data:            Status

         One byte of data is returned
         B0..3 0
         B4    CTS
                 0 = inactive
                 1 = active
         B5    DSR
                 0 = inactive
                 1 = active
         B6    Ring Indicator (RI)
                 0 = inactive
                 1 = active
         B7    Receive Line Signal Detect (RLSD)
                 0 = inactive
                 1 = active
         */

        #FTDI_SIO_GET_MODEM_STATUS_REQUEST = this.#FTDI_SIO_GET_MODEM_STATUS;
        #FTDI_SIO_CTS_MASK 	= 0x10;
        #FTDI_SIO_DSR_MASK 	= 0x20;
        #FTDI_SIO_RI_MASK  	= 0x40;
        #FTDI_SIO_RLSD_MASK = 0x80;

        /* FTDI_SIO_SET_BITMODE */
        #FTDI_SIO_SET_BITMODE_REQUEST = this.#FTDI_SIO_SET_BITMODE;

        /* Possible bitmodes for FTDI_SIO_SET_BITMODE_REQUEST */
        #FTDI_SIO_BITMODE_RESET		= 0x00;
        #FTDI_SIO_BITMODE_CBUS		= 0x20;

        /* FTDI_SIO_READ_PINS */
        #FTDI_SIO_READ_PINS_REQUEST = this.#FTDI_SIO_READ_PINS;

        /*
         * FTDI_SIO_READ_EEPROM
         *
         * EEPROM format found in FTDI AN_201, "FT-X MTP memory Configuration",
         * http://www.ftdichip.com/Support/Documents/AppNotes/AN_201_FT-X%20MTP%20Memory%20Configuration.pdf
         */
        #FTDI_SIO_READ_EEPROM_REQUEST = this.#FTDI_SIO_READ_EEPROM;

        #FTDI_FTX_CBUS_MUX_GPIO	 = 0x8;
        #FTDI_FT232R_CBUS_MUX_GPIO = 0xa;

        /* Descriptors returned by the device

          Device Descriptor

         Offset	Field			Size	Value	Description
         0		bLength			1		0x12	Size of descriptor in bytes
         1		bDescriptorType	1		0x01	DEVICE Descriptor Type
         2		bcdUSB			2		0x0110	USB Spec Release Number
         4		bDeviceClass	1		0x00	Class Code
         5		bDeviceSubClass	1		0x00	SubClass Code
         6		bDeviceProtocol	1		0x00	Protocol Code
         7		bMaxPacketSize0 1		0x08	Maximum packet size for endpoint 0
         8		idVendor		2		0x0403	Vendor ID
         10		idProduct		2		0x8372	Product ID (FTDI_SIO_PID)
         12		bcdDevice		2		0x0001	Device release number
         14		iManufacturer	1		0x01	Index of man. string desc
         15		iProduct		1		0x02	Index of prod string desc
         16		iSerialNumber	1		0x02	Index of serial nmr string desc
         17		bNumConfigurations 1    0x01	Number of possible configurations

         Configuration Descriptor

         Offset	Field			Size	Value
         0	bLength			1	0x09	Size of descriptor in bytes
         1	bDescriptorType		1	0x02	CONFIGURATION Descriptor Type
         2	wTotalLength		2	0x0020	Total length of data
         4	bNumInterfaces		1	0x01	Number of interfaces supported
         5	bConfigurationValue	1	0x01	Argument for SetCOnfiguration() req
         6	iConfiguration		1	0x02	Index of config string descriptor
         7	bmAttributes		1	0x20	Config characteristics Remote Wakeup
         8	MaxPower		1	0x1E	Max power consumption

         Interface Descriptor

         Offset	Field			Size	Value
         0	bLength			1	0x09	Size of descriptor in bytes
         1	bDescriptorType		1	0x04	INTERFACE Descriptor Type
         2	bInterfaceNumber	1	0x00	Number of interface
         3	bAlternateSetting	1	0x00	Value used to select alternate
         4	bNumEndpoints		1	0x02	Number of endpoints
         5	bInterfaceClass		1	0xFF	Class Code
         6	bInterfaceSubClass	1	0xFF	Subclass Code
         7	bInterfaceProtocol	1	0xFF	Protocol Code
         8	iInterface		1	0x02	Index of interface string description

         IN Endpoint Descriptor

         Offset	Field			Size	Value
         0	bLength			1	0x07	Size of descriptor in bytes
         1	bDescriptorType		1	0x05	ENDPOINT descriptor type
         2	bEndpointAddress	1	0x82	Address of endpoint
         3	bmAttributes		1	0x02	Endpoint attributes - Bulk
         4	bNumEndpoints		2	0x0040	maximum packet size
         5	bInterval		1	0x00	Interval for polling endpoint

         OUT Endpoint Descriptor

         Offset	Field			Size	Value
         0	bLength			1	0x07	Size of descriptor in bytes
         1	bDescriptorType		1	0x05	ENDPOINT descriptor type
         2	bEndpointAddress	1	0x02	Address of endpoint
         3	bmAttributes		1	0x02	Endpoint attributes - Bulk
         4	bNumEndpoints		2	0x0040	maximum packet size
         5	bInterval		1	0x00	Interval for polling endpoint

         DATA FORMAT

         IN Endpoint

         The device reserves the first two bytes of data on this endpoint to contain
         the current values of the modem and line status registers. In the absence of
         data, the device generates a message consisting of these two status bytes
         every 40 ms *** (maybe 16ms for newer/higher clkd dev?)

         *** According to TN103:

           FTDI devices will return data to the host in 2 cases:
            •The IC has a full buffer of data to send back to the host. (64 bytes minus 2 status bytes)
            •The latency timer has expired. (default 16ms on windows driver; don't konw if this is device default)
                - 16ms latency timer fucks with ISR (maybe others?) datalogging normally with HTS

        The latency timer acts as a timeout on the receive buffer which will trigger the transmission
        of any data in the chip’s receive buffer back to the host.

        The latency timer acts as a timeout on the receive buffer which will trigger the transmission
        of any data in the chip’s receive buffer back to the host.  In cases when the amount of data
        being received is minimal, this prevents applications from having to wait a long time for a
        full packet.

        If the receive buffer of the chip is empty when the latency timer expires, 2 status
        bytes are returned which contain the modem status and line status of the UART.  For FT245
        devices, these bytes are still returned but have no meaning. If the latency timer is expiring
        before the receive buffer is full, short USB packets will be returned to the host.  As this is
        not the most efficient packet size, this may be unsuitable for some applications.

        For example, a UART receiving data at 9600 baud with a default latency timer value (16ms) will
        generate USB packets of around 16 bytes before the latency timer expires and transmits the
        data available back to the PC.  If 64 byte IN packets were desired to minimise the number of
        INs required to complete a read,the packet size could be increased by increasing the value of
        the latency timer.  In this case, a value greater than 64ms would be sufficient for the chip to
        transmit full USB packets back to the host assuming data was constantly being received by the
        UART.

        In the case of FTDI’s USB-UART devices, the IN packet size may appear to be dependent
        on baud rate.  This is not the case: it is simply that the UART may receive data faster at a
        higher baud rate and thus has a better chance of filling the buffer before the latency
        timer expires

        When optimising data throughput for FTDI devices, the following factors should be considered:
            •Send as much data to the IC from the host application as possible in a single write.
            This will maximise the size of the data packets being sent to the device and hence minimise
            the number of packets required and time to transfer an amount of data.

            •Set the latency timer to a value appropriate for the application.  Note that a low latency
            timer value may result in many short incoming USB packets rather than a single large packet,
            thus diminishing performance

         Byte 0: Modem Status

         Offset	Description
         B0	Reserved - must be 1
         B1	Reserved - must be 0
         B2	Reserved - must be 0
         B3	Reserved - must be 0
         B4	Clear to Send (CTS)
         B5	Data Set Ready (DSR)
         B6	Ring Indicator (RI)
         B7	Receive Line Signal Detect (RLSD)

         Byte 1: Line Status

         Offset	Description
         B0	Data Ready (DR)
         B1	Overrun Error (OE)
         B2	Parity Error (PE)
         B3	Framing Error (FE)
         B4	Break Interrupt (BI)
         B5	Transmitter Holding Register (THRE)
         B6	Transmitter Empty (TEMT)
         B7	Error in RCVR FIFO

         */
        #FTDI_RS0_CTS	=	(1 << 4);
        #FTDI_RS0_DSR	=	(1 << 5);
        #FTDI_RS0_RI	=	(1 << 6);
        #FTDI_RS0_RLSD	=	(1 << 7);

        #FTDI_RS_DR 	=	1;
        #FTDI_RS_OE 	=	(1 << 1);
        #FTDI_RS_PE 	=	(1 << 2);
        #FTDI_RS_FE 	=	(1 << 3);
        #FTDI_RS_BI 	=	(1 << 4);
        #FTDI_RS_THRE	=	(1 << 5);
        #FTDI_RS_TEMT	=	(1 << 6);
        #FTDI_RS_FIFO	=	(1 << 7);

        /*
         * OUT Endpoint
         *
         * This device reserves the first bytes of data on this endpoint contain the
         * length and port identifier of the message. For the FTDI USB Serial converter
         * the port identifier is always 1.
         *
         * Byte 0: Line Status
         *
         * Offset	Description
         * B0	Reserved - must be 1
         * B1	Reserved - must be 0
         * B2..7	Length of message - (not including Byte 0)
         *
         */

        constructor(device, portConfiguration) {
            this.device = device;
            this.portConfiguration = portConfiguration;

            this.interfaceNumber = 0;
            this.endpointIn = 0;
            this.endpointOut = 0;

            this.modemStatusByte = 0;
            this.lineStatusByte = 0;

            this.packetsReceived = 0;
        }

        connect(receiveCallback, errorCallback) {
            this.onReceive = receiveCallback;
            this.onReceiveError = errorCallback;

            let readLoop = () => {
                this.device.transferIn(this.endpointIn, 64).then(result => {
                    //console.log("Modem Status Byte:"+this.result.data[0])
                    //console.log("Line Status Byte:"+this.result.data[1])
                    let resultArray = new Uint8Array(result.data.buffer);

                    if (resultArray[0] != this.modemStatusByte)
                        this.modemStatusByte = resultArray[0];

                    if (resultArray[1] != this.lineStatusByte)
                        this.lineStatusByte = resultArray[1];

                    if (resultArray.length > 2) {
                        let dataArray = new Uint8Array(resultArray.length - 2);
                        for (let x=2;x<resultArray.length;x++) {
                            dataArray[x - 2] = resultArray[x];
                        }
                        this.onReceive(dataArray);
                    } else {
                        this.packetsReceived = this.packetsReceived + 1;
                    }

                    readLoop();

                }, error => {
                    this.onReceiveError(error);
                });
            };

            return this.device.open()
                .then(() => {

                    if (this.device.configuration === null) {
                        return this.device.selectConfiguration(1);
                    }
                })
                .then(() => {
                    var interfaces = this.device.configuration.interfaces;
                    /*console.log("interfaces:")
                    console.log(interfaces)*/
                    interfaces.forEach(element => {
                        element.alternates.forEach(elementalt => {
                            console.log(elementalt);
                            if (elementalt.interfaceClass==0xFF) {
                                this.interfaceNumber = element.interfaceNumber;
                                elementalt.endpoints.forEach(elementendpoint => {
                                    if (elementendpoint.direction == "out") {
                                        this.endpointOut = elementendpoint.endpointNumber;
                                    }
                                    if (elementendpoint.direction=="in") {
                                        this.endpointIn = elementendpoint.endpointNumber;
                                    }
                                })
                            }
                        })
                    })
                    /*console.log("in out");
                    console.log(this.endpointIn)
                    console.log(this.endpointOut)*/
                })
                .then(() => this.device.claimInterface(this.interfaceNumber))
                .then(() => this.device.selectAlternateInterface(this.interfaceNumber, 0))
                .then(() => {

                    let baud = this.portConfiguration.baudrate;

                    /*		    	console.log("controlTransfer out now for " + this.interfaceNumber)
                                    console.log("req: " + this.#FTDI_SIO_SET_BAUD_RATE)
                                    console.log("val: " + this.getBaudDivisor(baud) + '(' + baud + ')')
                                    console.log("ind: " + this.getBaudBase())*/

                    this.device.controlTransferOut({
                        requestType: 'vendor',
                        recipient: "device",
                        request: this.#FTDI_SIO_SET_BAUD_RATE,
                        value: this.getBaudDivisor(baud), // divisor_value
                        index: this.getBaudBase() // divisor_index
                    });
                })
                .then(() => {

                    return this.device.controlTransferIn({
                        requestType: 'vendor',
                        recipient: 'device',
                        request: this.#FTDI_SIO_GET_LATENCY_TIMER_REQUEST,
                        value: 0,
                        index: 0
                    },1);

                })
                .then((res) => {
                    this.device.latencyTimer = new Uint8Array(res.data.buffer)[0];

                    /*console.log("Current Latency Timer: ");
                        console.log(this.device.latencyTimer);*/

                    if (this.device.latencyTimer != 1) {
                        /*console.log("Setting latency timer to 1")*/
                        return this.device.controlTransferOut({
                            requestType: 'vendor',
                            recipient: "device",
                            request: this.#FTDI_SIO_SET_LATENCY_TIMER_REQUEST,
                            value: 1,
                            index: 0
                        });
                    }
                })
                .then((res) => {
                    return this.device.latencyTimer =   this.device.controlTransferIn({
                        requestType: 'vendor',
                        recipient: 'device',
                        request: this.#FTDI_SIO_GET_LATENCY_TIMER_REQUEST,
                        value: 0,
                        index: 0
                    },1);

                    /*	console.log(this.device.controlTransferOut({
                    'requestType': 'class',
                    'recipient': 'interface',
                    'request': 0x22,
                    'value': 0x01,
                    'index': this.interfaceNumber
                    }))*/
                })
                .then((res) => {
                    this.device.latencyTimer = new Uint8Array(res.data.buffer)[0];

                    console.log("Current Latency Timer: ");
                    console.log(this.device.latencyTimer);
                    readLoop();
                    return this.device;
                });
        }

        DIV_ROUND_CLOSEST(x, divisor)
        {
            let __x = x;
            let __d = divisor;
            return ((((x))-1) > 0 ||
                (((divisor))-1) > 0 ||
                (((__x) > 0) == ((__d) > 0))) ?
                (((__x) + ((__d) / 2)) / (__d)) :
                (((__x) - ((__d) / 2)) / (__d));
        }

        getBaudBase() {
            // older devices = 12000000 ?
            return 48000000;
        }

        getBaudDivisor(baud) {
            /*
                works for 232bm, 2232c, 232rl, ftx
            */

            let base = this.getBaudBase();

            //	static const unsigned char divfrac[8] = { 0, 3, 2, 4, 1, 5, 6, 7 };

            let divfrac = new Uint8Array(8);
            divfrac = [ 0, 3, 2, 4, 1, 5, 6, 7 ];

            let divisor = 0;

            let divisor3 = this.DIV_ROUND_CLOSEST(base, 2 * baud);
            divisor = divisor3 >> 3;
            divisor |= divfrac[divisor3 & 0x7] << 14;
            /* Deal with special cases for highest baud rates. */
            if (divisor == 1)
                divisor = 0;
            else if (divisor == 0x4001)
                divisor = 1;
            return divisor;

        }

        /* The SIO requires the first byte to have:
         *  B0 1
         *  B1 0
         *  B2..7 length of message excluding byte 0
         *
         * The new devices do not require this byte
         */

        send(data) {
            return this.device.transferOut(this.endpointOut, data);
        }

        disconnect() {
            /*return console.log(this.device.controlTransferOut({
                    'requestType': 'class',
                    'recipient': 'interface',
                    'request': 0x22,
                    'value': 0x01,
                    'index': this.interfaceNumber
                    }).then(()=>
             this.device.close()))*/
            this.device.close();
        }
    }

    class WebUSBSerialDevice {
        constructor(configuration) {
            if (!('usb' in navigator)) {
                throw new Error('USB Support not available!');
            }

            this.configuration = configuration || {
                // Whether or not to override/specify baud/bits/stop/parity
                overridePortSettings: false,

                // Default settings, only used when overridden
                baudrate: 9600,
                bits: 8,
                stop: 1,
                parity: false,

                // Some default FTDI device IDs
                // you can replace these with any device that has
                // an ftdi chip.
                deviceFilters: [
                    /*{ 'vendorId' : 0x0403, 'productId' : 0x6000 },
                    { 'vendorId' : 0x0403, 'productId' : 0x6001 },
                    { 'vendorId' : 0x0403, 'productId' : 0x6010 },
                    { 'vendorId' : 0x0403, 'productId' : 0x6011 },
                    { 'vendorId' : 0x0403, 'productId' : 0x6014 }*/
                ]
            }

            this.devices = [];
            //this.ports = [];
        }

        async getAvailablePorts() {
            this.devices = await navigator.usb.getDevices();

            return this.devices.map(device => new WebUSBSerialPort(device));
        }

        async requestNewPort() {
            try {
                let device = await navigator.usb.requestDevice({
                    filters : this.configuration.deviceFilters
                });

                if (!(device in this.devices))
                    this.devices.push(device);

                return new WebUSBSerialPort(device, this.configuration);
            } catch (e) {
                throw new Error(e);
            }
        }

    }
    /**
     * make this sort of look like WebSerial.
     */
    export class FtdiSerial {
        async requestPort() {
            return new FtdiPortDataSource();
        }
    }

    export class FtdiPortDataSource {
        /**
         * When there is no data available, wait this amount of time before checking again.
         * @type {number}
         */
        noDataWaitTimeMs = 300;
        readable;
        writable;
        device;
        devicePort;
        inboundDataQueue = null;
        decoder = new TextDecoder();

        constructor() {
        }

        // must call this from a button
        async open(params) {
            this.device = new WebUSBSerialDevice({
                overridePortSettings: true, // TODO: not supported yet, always overrides baudrate
                // these are the defaults, this config is only used if above is true
                baudrate: params.baudRate,
                bits: 8, // TODO: override not supported yet
                stop: 1, // TODO: override not supported yet
                parity: false, // TODO: override not supported yet
                deviceFilters: [
                    // example filtered device; see code for more examples
                    {'vendorId': 0x0403, 'productId': 0x6001}, // 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC
                ]
            });


            return new Promise((resolve, reject) => {
                this.device.requestNewPort().then((port) => {
                    this.devicePort = port;
                    this.readable = getReadableStreamFromDataSource(this); // this starts reading immediately  :(
                    this.writable = this.getWritableStreamFromDataSink(this);
                    resolve(port);
                }).catch((err) => {
                    console.log(`error requesting a port: ${err}`);
                    reject(err);
                });
            })
        }

        getWritableStreamFromDataSink(dataSink) {
            const queuingStrategy = new CountQueuingStrategy({ highWaterMark: 1 });
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();
            return new WritableStream(
                {
                    // Implement the sink
                    write(chunk) {
                        const data = decoder.decode(chunk);
                        console.log(`sending to ftdi: ${data}`);
                        return new Promise((resolve, reject) => {
                            dataSink.devicePort.send(chunk).then((res) => {
                                console.log(`successfully sent to ftdi: ${res.status}, bytesWritten: ${res.bytesWritten}`);
                                resolve(res)
                            }).catch((err) => {
                                console.log(`error sending to ftdi: ${err.toString()}`);
                                reject(err)
                            });
                        });
                    },
                    close() {
                        console.log("ftdi sink closed")
                    },
                    abort(err) {
                        console.log("ftdi Sink error:", err);
                    },
                },
                queuingStrategy
            );
        }

        // called internally
        connectToPort() {
            // something wrong with the driver? in external control mode, we no longer get data callbacks here.

            this.inboundDataQueue = []; // this also flags that we're initialized
            try {
                // try to connect, connect receives two parameters: data callback and error callback
                this.devicePort.connect((chunk) => {
                    // this is data callback, print data to console
                    const decodedData = this.decoder.decode(chunk);
                    // logData(`${decodedData}`);
                    logSource(`data callback got ${chunk.length} bytes: ${decodedData}\n`)

                    // chunk is a Uint8Array so we can't just use + or +=
                    this.inboundDataQueue.push(chunk);
                }, (error) => {
                    // called if error receiving data
                    logSource("Error receiving data: " + error)
                });
                logSource('connected (probably)');
            } catch (e) {
                // called if can't get a port
                logSource("Error connecting to port: " + e.error)
                logSource(e)
            }
        }


        // Method returning promise when this push source is readable.
        async dataRequest() {
            const result = {
                bytesRead: 0,
                data: "",
            };

            if (this.inboundDataQueue === null) {
                this.connectToPort();
            }

            if (this.inboundDataQueue.length === 0) {
                // Data not available. We need a way to know if there is no more data or if we're just waiting.
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log(`no data, waiting a bit...`);
                        this.dataRequest().then((res) => {
                            console.log(`trying to get more data...`);
                            resolve(res)
                        });  // is this the correct way to chain Promises?
                    }, this.noDataWaitTimeMs); // wait a little bit
                });
            }

            const chunks = this.inboundDataQueue.splice(0, this.inboundDataQueue.length); // is this thread safe?

            return new Promise((resolve) => {
                let bigChunkSize = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const bigChunk = new Uint8Array(bigChunkSize);

                // this has side effects...
                chunks.reduce((chunkIndex, chunk) => {
                    bigChunk.set(chunk, chunkIndex);
                    return (chunkIndex + chunk.length);
                }, 0);

                result.data = bigChunk;
                result.bytesRead = bigChunkSize;
                resolve(result);
            });
        }

        // Dummy close function
        close() {
            return;
        }
    }

    /*
      mock data source idea from https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams
     */

    const utf8Decoder = new TextDecoder("utf-8");

    /**
     * from https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader/read#example_2_-_handling_text_line_by_line
     * @param reader
     * @returns an iterator that returns data from the reader broken up into lines
     */

    export async function* getLines(reader) {
        async function readFromReader() {
            const result = await reader.read();
            if (!result.done && result.value) {
                // appendRaw(utf8Decoder.decode(result.value));
            }
            return result;
        }

        let {value: chunk, done: readerDone} = await readFromReader();
        chunk = chunk ? utf8Decoder.decode(chunk, {stream: true}) : "";


        let re = /\r\n|\n|\r/gm;
        let startIndex = 0;

        for (; ;) {
            let result = re.exec(chunk);
            if (!result) {
                if (readerDone) {
                    break;
                }
                let remainder = chunk.substring(startIndex);
                ({value: chunk, done: readerDone} = await readFromReader());
                chunk =
                    remainder + (chunk ? utf8Decoder.decode(chunk, {stream: true}) : "");
                startIndex = re.lastIndex = 0;
                continue;
            }
            yield chunk.substring(startIndex, result.index);
            startIndex = re.lastIndex;
        }
        if (startIndex < chunk.length) {
            // last line didn't end in a newline char
            yield chunk.substring(startIndex);
        }
    }



    export function getReadableStreamFromDataSource(pushSource) {
        return new ReadableStream({
            start(controller) {
                readRepeatedly().catch((e) => controller.error(e));

                function readRepeatedly() {
                    return pushSource.dataRequest().then((result) => {
                        if (result.data.length === 0) {
                            logSource(`No data from source: closing`);
                            controller.close();
                            return;
                        }

                        // logSource(`Enqueue data: ${result.data}`);
                        controller.enqueue(result.data);
                        return readRepeatedly();
                    });
                }
            },

            cancel() {
                logSource(`cancel() called on underlying source`);
                pushSource.close();
            },
        });
    }


    export class DataFilePushSource {
        static DEFAULT_DELAY_MS = 10;
        static encoder = new TextEncoder();
        reader = null;
        buffer = null;
        bufferIndex = 0;
        fileOrUrl;
        delayMs;

        constructor(fileOrUrl, delayMs= DataFilePushSource.DEFAULT_DELAY_MS) {
            this.fileOrUrl = fileOrUrl;
            this.delayMs = delayMs;
        }

        // Method returning promise when this push source is readable.
        async dataRequest() {
            const result = {
                bytesRead: 0,
                data: "",
            };

            if (this.buffer === null || this.bufferIndex >= this.buffer.length) {
                // need (more) data
                if (this.reader === null) {
                    this.reader = await fetch(this.fileOrUrl).then((result) => {
                        if (result.ok) {
                            return result.body.getReader();
                        } else {
                            throw new Error(`Failed to load protocol definitions. error: ${result.status}`);
                        }
                    })
                }

                const result = await this.reader.read();
                this.bufferIndex = 0;
                if (result.done) {
                    // no more data
                    this.buffer = []
                } else {
                    this.buffer = result.value;
                }
            }

            if (this.buffer.length === 0) {
                // no more data
                return new Promise((resolve) => resolve(result));
            }

            // some data not sent
            const end = this.bufferIndex + (this.bufferIndex + 3 < this.buffer.length ? 3 : this.buffer.length);
            const chunk = this.buffer.slice(this.bufferIndex, end);
            this.bufferIndex += chunk.length;
            return new Promise((resolve) => {
                // Emulate slow read of data
                setTimeout(() => {
                    result.data = chunk;
                    result.bytesRead = chunk.length;
                    resolve(result);
                }, this.delayMs);
            });
        }

        // Dummy close function
        close() {
            return;
        }
    }



    export function logSource(result) {
        console.log(`source: ${result}`);
    }

    export function logData(result) {
        // console.log(`data: ${result}`);
    }

    /*
    External control for the PortaCount 8020a
    The technical addendum describes the interface. Starts on page 13.
     https://tsi.com/getmedia/0d5db6cd-c54d-4644-8c31-40cc8c9d8a9f/PortaCount_Model_8020_Technical_Addendum_US?ext=.pdf
     */

    export class ExternalControl {
        static INVOKE_EXTERNAL_CONTROL = "J";
        static RELEASE_FROM_EXTERNAL_CONTROL = "G";
        static TEST_TO_SEE_N95_COMPANION_IS_ATTACHED = "Q";
        static SWITCH_VALVE_ON = "VN"; // ambient
        static SWITCH_VALVE_OFF = "VF"; // sample
        static DISABLE_CONTINUOUS_DATA_TRANSMISSION = "ZD";
        static ENABLE_CONTINUOUS_DATA_TRANSMISSION = "ZE";
        static REQUEST_RUNTIME_STATUS_OF_BATTERY_AND_SIGNAL_PULSE = "R";
        static REQUEST_SETTINGS = "S";
        static TURN_POWER_OFF = "Y";
        static SET_MASK_SAMPLE_TIME = "PTMxxvv";  // xx = exercise num [1..12], vv = time in seconds [10..99]
        static SET_AMBIENT_SAMPLE_TIME = "PTA00vv";  // vv = time in seconds [5..99]
        static SET_MASK_SAMPLE_PURGE_TIME = "PTPM0vv"; // vv = time in seconds [11..25]
        static SET_AMBIENT_SAMPLE_PURGE_TIME = "PTPA0vv"; // vv = time in seconds [4..25]
        static SET_FIT_FACTOR_PASS_LEVEL = "PPxxvvvvv"; // xx = memory location [1..12], vvvvv = pass level [0..64000]

        static DISPLAY_CONCENTRATION_ON_PORTACOUNT_PLUS = "Dxxxxxx.xx";
        static DISPLAY_FIT_FACTOR_PASS_LEVEL_ON_PORTACOUNT_PLUS = "Lxxxxxx";
        static DISPLAY_FIT_FACTOR_ON_PORTACOUNT_PLUS = "Fxxxxxx.x";
        static DISPLAY_OVERALL_FIT_FACTOR_ON_PORTACOUNT_PLUS = "Axxxxxx.x";
        static DISPLAY_EXERCISE_NUMBER_ON_PORTACOUNT_PLUS = "Ixxxxxxxx";
        static CLEAR_DISPLAY_ON_PORTACOUNT_PLUS = "K";
        static SOUND_BEEPER_INSIDE_THE_PORTACOUNT_PLUS = "Bxx";

        static encoder = new TextEncoder();
        static staticWriter; // todo: rewrite button setup so we don't need this static field

        constructor(writer) {
            this.writer = writer;
            ExternalControl.staticWriter = writer;
        }


        static setupButtons(containerElement) {
            const controlModeButton = this.makeButton("control-type-button", "Internal Control");
            controlModeButton.style.backgroundColor = "yellow";
            controlModeButton.onclick = (event) => {
                if(controlModeButton.value === "Internal Control") {
                    controlModeButton.value = "External Control";
                    controlModeButton.style.backgroundColor = "green";
                    this.assumeManualControl();
                } else {
                    controlModeButton.value = "Internal Control";
                    controlModeButton.style.backgroundColor = "yellow";
                    this.releaseManualControl();
                }
            }
            containerElement.appendChild(controlModeButton);

            const valvePositionButton = this.makeButton("valve-position-button", "Sampling from Mask");
            valvePositionButton.style.backgroundColor = "yellow";
            valvePositionButton.onclick = (event) => {
                if(valvePositionButton.value === "Sampling from Ambient") {
                    valvePositionButton.value = "Sampling from Mask";
                    valvePositionButton.style.backgroundColor = "green";
                    this.sampleMask()
                } else {
                    valvePositionButton.value = "Sampling from Ambient";
                    valvePositionButton.style.backgroundColor = "yellow";
                    this.sampleAmbient();
                }
            }
            containerElement.appendChild(valvePositionButton);

            const dataTransmitModeButton = this.makeButton("data-transmit-mode-button", "Transmitting");
            dataTransmitModeButton.style.backgroundColor = "green";
            dataTransmitModeButton.onclick = (event) => {
                if(dataTransmitModeButton.value === "Paused") {
                    dataTransmitModeButton.value = "Transmitting";
                    dataTransmitModeButton.style.backgroundColor = "green";
                    this.enableDataTransmission();
                } else {
                    dataTransmitModeButton.value = "Paused";
                    dataTransmitModeButton.style.backgroundColor = "yellow";
                    this.disableDataTransmission();
                }
            }
            containerElement.appendChild(dataTransmitModeButton);

            const requestSettingsButton = this.makeButton("request-settings-button", "Request Settings");
            requestSettingsButton.onclick = (event) => {
                this.requestSettings();
            }
            containerElement.appendChild(requestSettingsButton);

            const beepButton = this.makeButton("beep-button", "Beep!");
            beepButton.onclick = (event) => {
                this.beep();
            }
            containerElement.appendChild(beepButton);

            const powerOffButton = this.makeButton("power-off-button", "Power Off");
            powerOffButton.onclick = (event) => {
                this.powerOff();
            }
            containerElement.appendChild(powerOffButton);
        }

        static makeButton(id, name) {
            const controlModeButton = document.createElement("input");
            controlModeButton.setAttribute("type", "button");
            controlModeButton.setAttribute("value", name);
            controlModeButton.id = id;
            return controlModeButton;
        }

        static assumeManualControl() {
            this.sendCommand(ExternalControl.INVOKE_EXTERNAL_CONTROL);
        }

        static releaseManualControl() {
            this.sendCommand(ExternalControl.RELEASE_FROM_EXTERNAL_CONTROL);
        }

        static enableDataTransmission() {
            this.sendCommand(ExternalControl.ENABLE_CONTINUOUS_DATA_TRANSMISSION);
        }

        static disableDataTransmission() {
            this.sendCommand(ExternalControl.DISABLE_CONTINUOUS_DATA_TRANSMISSION);
        }

        static sampleAmbient() {
            this.sendCommand(ExternalControl.SWITCH_VALVE_ON);
        }

        static sampleMask() {
            this.sendCommand(ExternalControl.SWITCH_VALVE_OFF);
        }

        static requestSettings() {
            this.sendCommand(ExternalControl.REQUEST_SETTINGS);
        }

        static powerOff() {
            this.sendCommand(ExternalControl.TURN_POWER_OFF);
        }

        static beep(tenthsOfSeconds = 2) {
            this.sendCommand(`B${String(tenthsOfSeconds).padStart(2, "0")}`);
        }

        static sendCommand(command) {
            let terminalCommand = `${command}\r`;
            let chunk = this.encoder.encode(terminalCommand);
            this.staticWriter.write(chunk);
        }
    }

    /*
    Stores raw data lines from the data collector. Suitable for parsing with the updated simulator.
     */

    export class SimpleDB {
        static DEFAULT_DB_NAME = "raw-serial-line-data-db";
        static SERIAL_LINE_OBJECT_STORE = "serial-line-data";
        db;
        dbName;
        constructor(name = SimpleDB.DEFAULT_DB_NAME) {
            this.dbName = name;
            const request = window.indexedDB.open(this.dbName, 1);
            // use arrow here so `this` inside the callback points to the SimpleDB instance.
            request.onsuccess = (event) => this.onOpenSuccess(event);
            request.onerror = (event) => this.onOpenError(event);
            request.onupgradeneeded = (event) => this.onUpgradeNeeded(event);
        }

        onOpenSuccess(event) {
            let database = event.target.result;
            console.log("Database Opened", database, event);
            this.db = database;
        }

        onOpenError(event) {
            console.error(`Database error: ${event.target.error?.message}`);
        }

        onUpgradeNeeded(event) {
            // Save the IDBDatabase interface
            const theDb = event.target.result;

            console.warn(`Database upgrade needed: ${theDb.name}`);
            // Create an objectStore for this database
            const objectStore = theDb.createObjectStore(SimpleDB.SERIAL_LINE_OBJECT_STORE, {autoIncrement: true, keyPath: "index"});
        }


        // TODO: wrap these into an object
        static ONE_HOUR = 60 * 60 * 1000;
        keepRecords = [];
        now = new Date(); // use .getTime() to get epoch time
        timeCutoff = this.getUpdatedTimeCutoff(this.now.getTime());

        /**
         * Return a recent contiguous block of lines. Look at the timestamp of the record. Stop when there is a gap of more than 1 hour between timestamps.
         * Don't return anything if the most recent record is more than 1 hour old.
         * @param callback
         */
        getSomeRecentLines(callback) {
            const transaction = this.openTransaction("readonly");
            const request = transaction.objectStore(SimpleDB.SERIAL_LINE_OBJECT_STORE).openCursor(null, "prev");
            let done = false;

            request.onerror = (event) => {
                console.log(`getSomeRecentLines openCursor request error ${event}`);
            }
            request.onsuccess = (event) => {
                console.log(`getSomeRecentLines openCursor request complete: ${event}`);
                const cursor = event.target.result;
                if (cursor) {
                    // cursor.key contains the key of the current record being iterated through
                    // note that there is no cursor.value, unlike for openCursor
                    // this is where you'd do something with the result
                    console.log(`got key ${cursor.key}`);

                    const recordTimestamp = Date.parse(cursor.value.timestamp);
                    if( recordTimestamp > this.timeCutoff) {
                        // keep
                        this.keepRecords.push(cursor.value);
                        this.timeCutoff = this.getUpdatedTimeCutoff(recordTimestamp);
                        cursor.continue();
                    } else {
                        // done
                        // how to abort / close the cursor?
                        console.log(`stopping after ${this.keepRecords.length} records. other records are too old.`);
                        done = true;
                    }

                    // callback();
                } else {
                    // no more results
                    console.log("cursor done");
                    done = true;
                }

                if(done) {
                    // now we can call the callback with records we're keeping in order of oldest to newest
                    console.log(`collected ${this.keepRecords.length} records`);
                    while (this.keepRecords.length > 0) {
                        callback(this.keepRecords.pop());
                    }
                }
            }
        }

        getUpdatedTimeCutoff(recordTimestamp) {
            // return recordTimestamp - SimpleDB.ONE_HOUR;
            return recordTimestamp - 150* 60*1000; // some minute for debugging
        }

        /**
         * Return the json representation of the data that was inserted. Includes the generated primary key.
         * @param record
         */
        addLine(line) {
            if(!this.db) {
                console.log("database not ready");
                return {};
            }
            const transaction = this.openTransaction("readwrite");

            const record = {
                timestamp: new Date().toISOString(),
                data: line,
            };
            const request = transaction.objectStore(SimpleDB.SERIAL_LINE_OBJECT_STORE).add(record);
            request.onerror = (event) => {
                console.log(`addRecord request error ${event}`);
            }
            request.onsuccess = (event) => {
                console.log(`addRecord request complete: ${event}, new key is ${request.result}`);
            }
        }

        openTransaction(mode) {
            const transaction = this.db.transaction([SimpleDB.SERIAL_LINE_OBJECT_STORE], mode);
            transaction.oncomplete = (event) => {
                console.log(`transaction complete: ${event}`);
            }
            transaction.onerror = (event) => {
                console.log(`transaction error ${event}`);
            }
            return transaction;
        }
    }

    /*
    Stores data from results table.
     */

    export class SimpleResultsDB {
        static DEFAULT_DB_NAME = "fit-test-data-db";
        static TEST_RESULTS_OBJECT_STORE = "test-results-table-data";
        db;
        dbName;
        constructor(name = SimpleResultsDB.DEFAULT_DB_NAME) {
            this.dbName = name;
            const request = window.indexedDB.open(this.dbName, 2);
            // use arrow here so `this` inside the callback points to the SimpleResultsDB instance.
            request.onsuccess = (event) => this.onOpenSuccess(event);
            request.onerror = (event) => this.onOpenError(event);
            request.onupgradeneeded = (event) => this.onUpgradeNeeded(event);
        }

        onOpenSuccess(event) {
            let database = event.target.result;
            console.log("Database Opened", database, event);
            this.db = database;
        }

        onOpenError(event) {
            console.error(`Database error: ${event.target.error?.message}`);
        }

        onUpgradeNeeded(event) {
            // Save the IDBDatabase interface
            const theDb = event.target.result;

            console.warn(`Database upgrade needed: ${theDb.name}`);
            // Create an objectStore for this database
            const objectStore = theDb.createObjectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE, {autoIncrement: true, keyPath: "ID"});
        }


        // TODO: wrap these into an object
        static ONE_HOUR = 60 * 60 * 1000;
        keepRecords = [];
        now = new Date(); // use .getTime() to get epoch time
        timeCutoff = this.getUpdatedTimeCutoff(this.now.getTime());

        /**
         * Return a recent contiguous block of data. Look at the timestamp of the record. Stop when there is a gap of more than 1 hour between timestamps.
         * Don't return anything if the most recent record is more than 1 hour old.
         * @param callback
         */
        getSomeRecentData(callback) {
            const transaction = this.openTransaction("readonly");
            const request = transaction.objectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE).openCursor(null, "prev");
            let done = false;

            request.onerror = (event) => {
                console.log(`getSomeRecentData openCursor request error ${event}`);
            }
            request.onsuccess = (event) => {
                console.log(`getSomeRecentData openCursor request complete: ${event}`);
                const cursor = event.target.result;
                if (cursor) {
                    console.log(`got key ${cursor.key}`);

                    const recordTimestamp = Date.parse(cursor.value.Time);
                    if( recordTimestamp > this.timeCutoff) {
                        // keep
                        this.keepRecords.push(cursor.value);
                        this.timeCutoff = this.getUpdatedTimeCutoff(recordTimestamp);
                        cursor.continue();
                    } else {
                        // done
                        // how to abort / close the cursor?
                        console.log(`stopping after ${this.keepRecords.length} records. other records are too old.`);
                        done = true;
                    }

                    // callback();
                } else {
                    // no more results
                    console.log("cursor done");
                    done = true;
                }

                if(done) {
                    // now we can call the callback with records we're keeping in order of oldest to newest
                    console.log(`collected ${this.keepRecords.length} records`);
                    while (this.keepRecords.length > 0) {
                        callback(this.keepRecords.pop());
                    }
                }
            }
        }

        getUpdatedTimeCutoff(recordTimestamp) {
            return recordTimestamp - SimpleResultsDB.ONE_HOUR *999; // debugging multiply hours by some large number
        }

        /**
         * Return the json representation of the data that was inserted. Includes the generated primary key.
         * @param record
         */
        async createNewTest() {
            if(!this.db) {
                console.log("database not ready");
                return new Promise((resolve, reject) => reject("database not ready"));
            }
            const transaction = this.openTransaction("readwrite");

            const record = {
                // empty for now
            };
            const request = transaction.objectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE).add(record);
            return new Promise((resolve, reject) => {
                request.onerror = (event) => {
                    let errorMessage = `createNewTest request error ${event}`;
                    console.log(errorMessage);
                    reject(errorMessage);
                }
                request.onsuccess = (event) => {
                    console.log(`createNewTest request complete: ${event}, new key is ${request.result}`);
                    // TODO: fetch the whole record and return that instead of constructing this by hand?
                    resolve({ID: request.result});
                }
            });
        }

        async updateTest(record) {
            if(!this.db) {
                console.log("database not ready");
                return new Promise((resolve, reject) => reject("database not ready"));
            }

            // make sure ID is numeric?
            record.ID = Number(record.ID);
            const transaction = this.openTransaction("readwrite");

            const request = transaction.objectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE).put(record);
            return new Promise((resolve, reject) => {
                request.onerror = (event) => {
                    let errorMessage = `updateTest request error ${event}`;
                    console.log(errorMessage);
                    reject(errorMessage);
                }
                request.onsuccess = (event) => {
                    console.log(`updateTest request complete: ${event}, key is ${request.result}`);
                    resolve({ID: request.result}); // todo: return something more appropriate for an update
                }
            });
        }

        openTransaction(mode) {
            const transaction = this.db.transaction([SimpleResultsDB.TEST_RESULTS_OBJECT_STORE], mode);
            transaction.oncomplete = (event) => {
                console.log(`transaction complete: ${event}`);
            }
            transaction.onerror = (event) => {
                console.log(`transaction error ${event}`);
            }
            return transaction;
        }
    }

    class App {
        baudRateSelector = document.getElementById("baud-rate-selector")
        logTextArea = document.getElementById("log-text-area")
        rawDataTextArea = document.getElementById("raw-data")
        dataTextArea = document.getElementById("interpreted-data")
        instructionsTextArea = document.getElementById("instructions");


        connectedPort;
        reader;
        readableStreamClosed;
        writer;
        writableStreamClosed;
        simpleDb;
        simpleResultsDb;
        dataCollector;

        logit(message) {
            console.log(message);
            this.dataCollector.appendToLog(message);
        }


        serialProbe() {
            console.log("serialProbe...");
            if ("serial" in navigator) {
                this.logit("serial supported!")
            } else {
                this.logit("no serial support :(")
            }
            let promise = navigator.serial.getPorts().then((ports) => {
                let message = `got serial ports: ${ports.toString()}`;
                this.logit(message)
            })
        }

        serialRequest() {
            const baudRate = this.baudRateSelector.value;

            if ("serial" in navigator) {
                this.logit("serial supported!")
            } else {
                this.logit("no serial support. As of this writing, web serial is only supported on desktop chrome.")
            }

            let promise = navigator.serial.requestPort().then((port) => {
                this.logit(`got serial port ${port.toLocaleString()}, using baud rate ${baudRate}`)
                port.open({baudRate: baudRate}).then((event) => {
                    this.logit(`opened ${event}`)
                    this.monitor(port.readable.getReader());
                    this.control(port.writable.getWriter());
                })
            })
        }

        ftdiRequest() {
            const baudRate = this.baudRateSelector.value;
            const serial = new FtdiSerial();
            serial.requestPort().then((port) => {
                port.open({baudRate: baudRate}).then((event) => {
                    this.logit(`ftdi opened ${event}`)
                    this.monitor(port.readable.getReader());
                    this.control(port.writable.getWriter());
                })
            })
        }

        autodetectBaudRate() {
            // according to the 8020 technical manual, everything is N81
            // factory setting is 1200
            // supported values are 300, 600, 1200, 2400, 9600

        }

        loadFromSerialDataDatabase() {
            const dataCollector = this.dataCollector; // preserve the correct this pointer because this method is called from a callback
            const f = function (record) {
                console.log(`loading from db: ${record.data}\n`);
                dataCollector.processLine(record.data);
            };
            this.simpleDb.getSomeRecentLines(f);
        }

        loadFromResultsDatabase() {
            const f = function (record) {
                console.log(`loading from db: ${JSON.stringify(record)}\n`);
            };
            this.simpleResultsDb.getSomeRecentData(f);
        }


        // use simulator as data source
        simulatorRequest() {
            const fakeReader = getReadableStreamFromDataSource(new DataFilePushSource("/src/test-data.txt", 0)).getReader();
            this.monitor(fakeReader);
        }

        setupButtons() {
            const connectButton = document.getElementById("connect-button");
            connectButton.onclick = (event) => {
                const selectedDataSource = document.getElementById("data-source-selector").value
                switch (selectedDataSource) {
                    case "ftdi":
                        this.ftdiRequest();
                        break;
                    case "web-serial":
                        this.serialRequest();
                        break;
                    case "simulator":
                        this.simulatorRequest();
                        break;
                    case "database":
                        this.loadFromSerialDataDatabase();
                        break;
                    case "results-db":
                        this.loadFromResultsDatabase();
                        break;
                    default:
                        this.logit(`Unsupported data source: ${selectedDataSource}`);
                }
            }

            const downloadButton = document.getElementById("download-button");
            downloadButton.onclick = (event) => {
                const table = document.getElementById("fit-test-data-table");
                const selector = document.getElementById("download-file-format-selector");
                switch (selector.value) {
                    case "raw":
                        downloadRawData(this.rawDataTextArea);
                        break;
                    case "csv":
                        downloadTableAsCSV(table);
                        break;
                    case "json":
                        downloadTableAsJSON(table);
                        break;
                    default:
                        console.log(`unsupported download file format: ${selector.value}`);
                }
            }

            // const stop_monitor_button = document.getElementById("stop-monitor-button");
            // stop_monitor_button.onclick = (event) => {
            //     stopMonitor();
            // }
        }


        appendRaw(message) {
            this.rawDataTextArea.value += message;
            DataCollector.scrollToBottom(this.rawDataTextArea);
        }

        async control(writer) {
            const remoteControl = new ExternalControl(writer);
        }

        async monitor(reader) {
            for await (let line of getLines(reader)) {
                const timestamp = new Date().toISOString();
                if (line.trim().length > 0) {
                    // we only care about non-empty lines
                    this.appendRaw(`${timestamp} ${line}\n`); // not really raw anymore since we've re-chunked into lines.
                    this.simpleDb.addLine(line);
                }
                this.dataCollector.processLine(line);
            }
            console.log("monitor reached end of reader");
        }


        onConnect = function (event) {
            console.log(`connected ${event}`)
            this.connectedPort = event.target;
            this.monitor(this.connectedPort);
        };


        setupMonitor() {
            if("serial" in navigator) {
                navigator.serial.addEventListener('connect', this.onConnect)
            } else {
                console.log("navigator.serial not present")
            }
        }


        async stopMonitor() {
            this.logit("stopping monitor")
            const textEncoder = new TextEncoderStream();
            this.writer = textEncoder.writable.getWriter();
            this.writableStreamClosed = textEncoder.readable.pipeTo(this.connectedPort.writable);

            this.reader.cancel();
            await this.readableStreamClosed.catch(() => { /* Ignore */
            });

            await this.writer.close();
            await this.writableStreamClosed;

            await this.connectedPort.close();
        }

        maybeAutoConnect() {
            let promise = navigator.serial.getPorts().then((ports) => {
                let message = `got serial ports: ${ports.toString()}`;
                if (ports.length === 1) {
                    this.logit("found 1 serial port, attempting to auto-connect...")
                    const baudRate = this.baudRateSelector.value;
                    const port = ports[0];
                    port.open({baudRate: baudRate}).then((event) => {
                        this.logit(`opened ${event}`)
                        this.monitor(port.readable.getReader());
                    })
                }
            })

        }

        setupDB() {
            this.simpleDb = new SimpleDB();
            this.simpleResultsDb = new SimpleResultsDB()
            this.dataCollector = new DataCollector(this.logTextArea, this.dataTextArea, this.instructionsTextArea, this.simpleResultsDb);
        }
    }


    quickSetupSpeechSynthesis();

    const app = new App();
    app.setupDB();
    app.setupButtons();
    app.setupMonitor();
    ExternalControl.setupButtons(document.getElementById("portacount-controls-fieldset"));

    // maybeAutoConnect();
    // protect against un/reload most of the time
    window.addEventListener("beforeunload", (event) => {
        event.preventDefault();
    });

</script>
</body>
</html>
